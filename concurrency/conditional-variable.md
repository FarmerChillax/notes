# 第三十章-条件变量

目前为止，我们已经形成了锁的概念，并且看到了硬件和操作系统是如何正确组合来实现锁的。但锁并不是并发程序设计所需要的唯一原语。

比如在很多情况下，线程需要检查某一条件（condition）满意之后，才会继续运行。比如父线程等待子线程的`join` 函数。下面是一段自旋等待的代码：

```c
void *child(void *arg)
{
    printf("child\n");
    // do someting...
    // 修改判断条件
    done = 1;
    return NULL;
}

// 要父线程等待子线程的话，需要加个自旋锁，并加上判断条件
int main(int argc, char *argv[])
{
    printf("parent: begin\n");
    pthread_t c;
    Pthread_create(&c, NULL, child, NULL); // create child
    // XXX how to wait for child?
    // 等待判断条件done为1(子线程执行完成)，（一直占着CPU，很浪费）
    while (done == 0)
        ; // 自旋等待
    printf("parent: end\n");
    return 0;
}
```

这个方案无疑是能解决问题的，但效率比较低，因为主线程会自旋检查，浪费 CPU 时间。那么如果有一种方法可以让父线程休眠，直到等待的条件满足才唤醒执行，无疑会更加高效。

### 定义和程序

而这样的一种锁和休眠等待的组合，已经为我们封装好了。线程可以使用**条件变量（condition variable）**，来等待一个条件变成真。

条件变量是一个**显式队列**，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待（waiting）该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行。具体用法如下：

```c
// 声明
pthread_cond_t c
// 相关操作
wait()
signal()
```

wait()调用有一个参数，它是互斥量mutex。

条件变量一般要与锁一起使用，`wait()` 调用时，这个互斥量必须是已上锁状态（处于临界区内）。wait() 的职责是释放锁，并让调用线程休眠（原子地）。当线程被唤醒时（在另外某个线程发信号给它后），它必须重新获取锁(重新进入临界区)，再返回调用者。

实际应用时由**条件和锁**共同决定临界区，如果获得锁就进入临界区，但如果条件未满足，则暂时**放弃锁**退出临界区，直到被唤醒（且条件满足）时**重新上锁**进入临界区。典型的条件变量用法（伪代码）:

```c
lock(&mutex);//进入临界区，保护done及其他临界资源
while (done == 0) // 判断条件，判断时必须保证在临界区内
    wait(&cond, &mutex);// 条件不满足时放弃锁，暂时退出临界区
// 条件满足时，进入真正的临界区
/* do somting... */
unlock(&mutex);// 退出临界区
```

需要注意：**发信号时总是持有锁，**尽管并不是所有情况下都严格需要，但有效且简单的做法，还是在使用条件变量发送信号时持有锁。虽然上面的例子是必须加锁的情况，但也有一些情况可以不加锁，而这可能是你应该避免的。因此，为了简单，请在`调用 signal` 时`持有锁`（hold the lock when calling signal）。

这个提示的反面，即调用 wait 时持有锁，不只是建议，而是 wait 的语义强制要求的。因为 wait 调用总是假设你调用它时已经持有锁、调用者睡眠之前会释放锁以及返回前重新持有锁。因此，这个提示的一般化形式是正确的：调用 signal 和 wait 时要持有锁（hold the lock when calling signal or wait），你会保持身心健康的。

### 生产者/消费者（有界缓冲区）问题

本章要面对的下一个问题，就是生产者/消费者问题（producer/consumer），有的也叫「有界缓冲区（bounded buffer）」问题。


























































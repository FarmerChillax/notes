# 第三十二章-常见并发问题

从下面的统计中我们可以看出，常见的并发问题可以分为：「非死锁的缺陷」与「死锁缺陷」

<figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### 非死锁缺陷

非死锁缺陷主要可以概括为以下几个：

* 违反原子性

「违反原子性」是指违反了多次内存访问中预期的**可串行性**，也就是说临界区代码没有被锁保护起来（即代码段本意是原子的，但在执行中并没有强制实现原子性）。如下面的代码，解决方法也就是加锁:

```c
Thread 1::
    // 判断和赋值应该是原子性的
    if (thd->proc_info)
    {
        ...
        fputs(thd->proc_info, ...);
        ...
    }

Thread 2::
    thd->proc_info = NULL;
```

* 违反顺序性

两个内存访问的**预期顺序**被打破了（即 A 应该在 B 之前执行，但是实际运行中却不是这个顺序）比如下面的这段代码中，如果 mState = mThread->State 语句先执行，则 mThread 为空。可以通过加**条件变量**(或信号量)解决：

```c
Thread 1::
    void init()
    {
        ...
        mThread = PR_CreateThread(mMain, ...);
        ...
    }

Thread 2::
    void mMain(...)
    {
        ...
        mState = mThread->State;
        ...
    }
```



### 死锁缺陷



#### 为什么发生死锁





#### 产生死锁的条件





#### 预防死锁

* 循环等待
* 持有并等待
* 非抢占
* 互斥



#### 通过调度避免死锁

只要 T1 和 T2 (需要同一个锁的线程)不同时运行，就不会产生死锁。但这样就失去了并发性

[![F32.1](https://hjk.life/assets/img/2022-06-16-operating-systems-26/F32.1.jpg)](https://hjk.life/assets/img/2022-06-16-operating-systems-26/F32.1.jpg)

\


#### 检查和恢复

最后一种常用的策略就是允许死锁偶尔发生，检查到死锁时再采取行动。

> 提示：不要总是完美（TOM WEST 定律）
>
> Tom West 是经典的计算机行业小说《Soul of a New Machine》的主人公，有一句很棒的工程格言：“不是所有值得做的事情都值得做好”。`如果坏事很少发生，并且造成的影响很小，那么我们不应该去花费大量的精力去预防它`。当然，如果你在制造航天飞机，事故会导致航天飞机爆炸，那么你应该忽略这个建议。

很多数据库系统使用了**死锁检测和恢复技术**。死锁检测器会定期运行，通过构建资源图来检查循环。当循环（死锁）发生时，系统需要重启。如果还需要更复杂的数据结构相关的修复，那么需要人工参与。















